var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CellArrays","category":"page"},{"location":"#CellArrays","page":"Home","title":"CellArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CellArrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CellArrays]","category":"page"},{"location":"#CellArrays.CellArrays","page":"Home","title":"CellArrays.CellArrays","text":"Module CellArrays\n\nProvides support for an AbstractArray subtype CellArray, which represents arrays with cells that can contain logical arrays instead of single values; the data is stored in an optimal fashion for GPU HPC applications.\n\nGeneral overview and examples\n\nhttps://github.com/omlins/CellArray.jl\n\nConstructors\n\nCellArray\nCPUCellArray\nCuCellArray\nROCCellArray\n\nFunctions (additional to standard AbstractArray functionality)\n\ncellsize\nblocklength\n\nTo see a description of a constructor or function type ?<constructorname> or ?<functionname>, respectively.\n\nnote: Performance note\nIf a CellArray's cells contain more than what fits into registers, the performance on Nvidia GPUs will deviate from the optimal, if access is not performed by accessing the cells' values individually to reduce register pressure.\n\n\n\n\n\n","category":"module"},{"location":"#CellArrays.CPUCellArray","page":"Home","title":"CellArrays.CPUCellArray","text":"CPUCellArray{T<:Cell,N,B,T_elem} <: AbstractArray{T,N} where Cell <: Union{Number, SArray, FieldArray}\n\nN-dimensional CellArray with cells of type T, blocklength B, and T_array being an Array of element type T_elem: alias for CellArray{T,N,B,Array{Telem,CellArrays.N}}.\n\n\n\n\n\n","category":"type"},{"location":"#CellArrays.CellArray","page":"Home","title":"CellArrays.CellArray","text":"CellArray{T<:Cell,N,B,T_array} <: AbstractArray{T,N} where Cell <: Union{Number, SArray, FieldArray}\n\nN-dimensional array with elements of type T, where T are Cells of type Number, SArray or FieldArray. B defines the blocklength, which refers to the amount of values of a same Cell field that are stored contigously (B=1 means array of struct like storage; B=prod(dims) means array struct of array like storage; B=0 is an alias for B=prod(dims), enabling better peformance thanks to more specialized dispatch). T_array defines the array type used for storage.\n\n\n\nCellArray{T,N,B}(T_arraykind, undef, dims)\nCellArray{T,B}(T_arraykind, undef, dims)\nCellArray{T}(T_arraykind, undef, dims)\n\nConstruct an uninitialized N-dimensional CellArray containing Cells of type T which are stored in an array of kind T_arraykind.\n\n\n\nCPUCellArray{T,B}(undef, dims)\nCPUCellArray{T}(undef, dims)\n\nCuCellArray{T,B}(undef, dims)\nCuCellArray{T}(undef, dims)\n\nROCCellArray{T,B}(undef, dims)\nROCCellArray{T}(undef, dims)\n\nConstruct an uninitialized N-dimensional CellArray containing Cells of type T which are stored in an array of kind Array, CuArray or ROCArray depending on the constructor chosen (CPUCellArray or CuCellArray or ROCCellArray) .\n\nnote: Performance note\nBest performance on GPUs is in general obtained with B=0 as set by default. B=1 migth give better performance in certain cases. Other values of B do with the current implementation not lead to optimal performance on GPU.\n\n\n\n\n\n","category":"type"},{"location":"#CellArrays.CuCellArray","page":"Home","title":"CellArrays.CuCellArray","text":"CuCellArray{T<:Cell,N,B,T_elem} <: AbstractArray{T,N} where Cell <: Union{Number, SArray, FieldArray}\n\nN-dimensional CellArray with cells of type T, blocklength B, and T_array being a CuArray of element type T_elem: alias for CellArray{T,N,B,CuArray{Telem,CellArrays.N}}.\n\n\n\n\n\n","category":"type"},{"location":"#CellArrays.ROCCellArray","page":"Home","title":"CellArrays.ROCCellArray","text":"ROCCellArray{T<:Cell,N,B,T_elem} <: AbstractArray{T,N} where Cell <: Union{Number, SArray, FieldArray}\n\nN-dimensional CellArray with cells of type T, blocklength B, and T_array being a ROCArray of element type T_elem: alias for CellArray{T,N,B,ROCArray{Telem,CellArrays.N}}.\n\n\n\n\n\n","category":"type"},{"location":"#CellArrays.blocklength-Union{Tuple{CellArray{T, N, B, T_array}}, Tuple{T_array}, Tuple{B}, Tuple{N}, Tuple{T}} where {T, N, B, T_array}","page":"Home","title":"CellArrays.blocklength","text":"blocklength(A)\n\nReturn the blocklength of CellArray A.\n\n\n\n\n\n","category":"method"},{"location":"#CellArrays.cellsize-Tuple{AbstractArray}","page":"Home","title":"CellArrays.cellsize","text":"cellsize(A)\ncellsize(A, dim)\n\nReturn a tuple containing the dimensions of A or return only a specific dimension, specified by dim.\n\n\n\n\n\n","category":"method"},{"location":"#CellArrays.field-Union{Tuple{T_array}, Tuple{N}, Tuple{T}, Tuple{CellArray{T, N, 0, T_array}, Int64}} where {T, N, T_array}","page":"Home","title":"CellArrays.field","text":"field(A, indices)\n\nReturn an array view of the field of CellArray A designated with indices (modifying the view will modify A). The view's dimensionality and size are equal to A's. The operation is not supported if parameter B of A is neither 0 nor 1.\n\nArguments\n\nindices::Int|NTuple{N,Int}: the indices that designate the field in accordance with A's cell type.\n\n\n\n\n\n","category":"method"}]
}
